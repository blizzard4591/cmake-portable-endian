/*
 * Endianness - Detected Files and Settings
 *
 * This file is parsed by CMake during makefile generation
 */

#ifndef ENDIANNESS_GENERATED_CONFIG_H_
#define ENDIANNESS_GENERATED_CONFIG_H_

// If a non-system implementation is forced, dont define any headers as available
#cmakedefine ENDIANNESS_CONFIG_FORCE_NON_SYSTEM_IMPLEMENTATION

#ifndef ENDIANNESS_CONFIG_FORCE_NON_SYSTEM_IMPLEMENTATION

// Whether endian.h is available
#cmakedefine ENDIANNESS_CONFIG_HAVE_ENDIAN_H

// Whether sys/endian.h is available
#cmakedefine ENDIANNESS_CONFIG_HAVE_SYS_ENDIAN_H

// Whether sys/param.h is available
#cmakedefine ENDIANNESS_CONFIG_HAVE_SYS_PARAM_H

// Whether inttypes.h is available
#cmakedefine ENDIANNESS_CONFIG_HAVE_INTTYPES_H

// Whether features.h is available
#cmakedefine ENDIANNESS_CONFIG_HAVE_FEATURES_H

// Whether libkern/OSByteOrder.h is available
#cmakedefine ENDIANNESS_CONFIG_HAVE_LIBKERN_OSBYTEORDER_H

// Whether arpa/inet.h is available
#cmakedefine ENDIANNESS_CONFIG_HAVE_ARPA_INET_H

// Whether netinet/in.h is available
#cmakedefine ENDIANNESS_CONFIG_HAVE_NETINET_IN_H

// Whether winsock2.h is available
#cmakedefine ENDIANNESS_CONFIG_HAVE_WINSOCK2_H

// Whether the endian.h or sys/endian.h functions use OpenBSD style (letoh16)
#cmakedefine ENDIANNESS_CONFIG_HAVE_OPENBSD_STYLE_ENDIAN_FUNCTIONS

// Whether the endian.h or sys/endian.h functions use Non-OpenBSD style (le16toh)
#cmakedefine ENDIANNESS_CONFIG_HAVE_NON_OPENBSD_STYLE_ENDIAN_FUNCTIONS

#endif // ENDIANNESS_CONFIG_FORCE_NON_SYSTEM_IMPLEMENTATION

@ENDIANNESS_CONFIG_TEST_RUN_OUTPUT@

/* ------------------------------------------------------------------- */
// Function declarations, depending on the macro values above.

#include <stddef.h>
#include <stdint.h>

// Necessary for some systems to expose functions
#if !defined(_WIN32) && !defined(ENDIANNESS_CONFIG_FORCE_NON_SYSTEM_IMPLEMENTATION)
#	define _BSD_SOURCE
#	define _SVID_SOURCE
#	define _DEFAULT_SOURCE
#endif

#ifdef ENDIANNESS_CONFIG_HAVE_ENDIAN_H
#	include <endian.h>
#endif

#ifdef ENDIANNESS_CONFIG_HAVE_SYS_ENDIAN_H
#	include <sys/endian.h>
#endif

#ifdef ENDIANNESS_CONFIG_HAVE_SYS_PARAM_H
#	include <sys/param.h>
#endif

#ifdef ENDIANNESS_CONFIG_HAVE_INTTYPES_H
#	include <inttypes.h>
#endif

#ifdef ENDIANNESS_CONFIG_HAVE_FEATURES_H
#	include <features.h>
#endif

#ifdef ENDIANNESS_CONFIG_HAVE_ARPA_INET_H
#	include <arpa/inet.h>
#endif

#ifdef ENDIANNESS_CONFIG_HAVE_NETINET_IN_H
#	include <netinet/in.h>
#endif

#ifdef ENDIANNESS_CONFIG_HAVE_LIBKERN_OSBYTEORDER_H
#	include <libkern/OSByteOrder.h>

#	define htobe16(x) OSSwapHostToBigInt16(x)
#	define htole16(x) OSSwapHostToLittleInt16(x)
#	define betoh16(x) OSSwapBigToHostInt16(x)
#	define letoh16(x) OSSwapLittleToHostInt16(x)

#	define htobe32(x) OSSwapHostToBigInt32(x)
#	define htole32(x) OSSwapHostToLittleInt32(x)
#	define betoh32(x) OSSwapBigToHostInt32(x)
#	define letoh32(x) OSSwapLittleToHostInt32(x)

#	define htobe64(x) OSSwapHostToBigInt64(x)
#	define htole64(x) OSSwapHostToLittleInt64(x)
#	define betoh64(x) OSSwapBigToHostInt64(x)
#	define letoh64(x) OSSwapLittleToHostInt64(x)

#elif defined(ENDIANNESS_CONFIG_HAVE_NON_OPENBSD_STYLE_ENDIAN_FUNCTIONS) && !defined(ENDIANNESS_CONFIG_HAVE_OPENBSD_STYLE_ENDIAN_FUNCTIONS)

#	define betoh16(x) be16toh((x))
#	define letoh16(x) le16toh((x))
#	define betoh32(x) be32toh((x))
#	define letoh32(x) le32toh((x))
#	define betoh64(x) be64toh((x))
#	define letoh64(x) le64toh((x))

#elif (defined(_WIN16) || defined(_WIN32) || defined(_WIN64)) && defined(ENDIANNESS_CONFIG_HAVE_WINSOCK2_H) && ((ENDIANNESS_CONFIG_ENDIAN_TYPE == ENDIANNESS_VAL_LITTLE_ENDIAN) || (ENDIANNESS_CONFIG_ENDIAN_TYPE == ENDIANNESS_VAL_BIG_ENDIAN))
#	if (ENDIANNESS_CONFIG_ENDIAN_TYPE == ENDIANNESS_VAL_LITTLE_ENDIAN)
#		define htobe16(x) htons(x)
#		define htole16(x) (x)
#		define betoh16(x) ntohs(x)
#		define letoh16(x) (x)
#		define htobe32(x) htonl(x)
#		define htole32(x) (x)
#		define betoh32(x) ntohl(x)
#		define letoh32(x) (x)
#		define htobe64(x) htonll(x)
#		define htole64(x) (x)
#		define betoh64(x) ntohll(x)
#		define letoh64(x) (x)
#	elif (ENDIANNESS_CONFIG_ENDIAN_TYPE == ENDIANNESS_VAL_BIG_ENDIAN)
		/* Could be Xbox 360 */
#		define htobe16(x) (x)
#		define htole16(x) __builtin_bswap16(x)
#		define betoh16(x) (x)
#		define letoh16(x) __builtin_bswap16(x)
#		define htobe32(x) (x)
#		define htole32(x) __builtin_bswap32(x)
#		define betoh32(x) (x)
#		define letoh32(x) __builtin_bswap32(x)
#		define htobe64(x) (x)
#		define htole64(x) __builtin_bswap64(x)
#		define betoh64(x) (x)
#		define letoh64(x) __builtin_bswap64(x)
#	endif

#elif !defined(ENDIANNESS_CONFIG_HAVE_NON_OPENBSD_STYLE_ENDIAN_FUNCTIONS) && !defined(ENDIANNESS_CONFIG_HAVE_OPENBSD_STYLE_ENDIAN_FUNCTIONS) && (defined(ENDIANNESS_CONFIG_HAVE_ARPA_INET_H) || defined(ENDIANNESS_CONFIG_HAVE_NETINET_IN_H)) && ((ENDIANNESS_CONFIG_ENDIAN_TYPE == ENDIANNESS_VAL_LITTLE_ENDIAN) || (ENDIANNESS_CONFIG_ENDIAN_TYPE == ENDIANNESS_VAL_BIG_ENDIAN))
#	if ENDIANNESS_CONFIG_ENDIAN_TYPE == ENDIANNESS_VAL_LITTLE_ENDIAN
#   	define htobe16(x) htons(x)
#		define htole16(x) (x)
#		define betoh16(x) ntohs(x)
#		define letoh16(x) (x)

#		define htobe32(x) htonl(x)
#		define htole32(x) (x)
#		define betoh32(x) ntohl(x)
#		define letoh32(x) (x)

#		define htobe64(x) (((uint64_t)htonl(((uint32_t)(((uint64_t)(x)) >> 32)))) | (((uint64_t)htonl(((uint32_t)(x)))) << 32))
#		define htole64(x) (x)
#		define betoh64(x) (((uint64_t)ntohl(((uint32_t)(((uint64_t)(x)) >> 32)))) | (((uint64_t)ntohl(((uint32_t)(x)))) << 32))
#		define letoh64(x) (x)
#	elif ENDIANNESS_CONFIG_ENDIAN_TYPE == ENDIANNESS_VAL_BIG_ENDIAN
#		define htobe16(x) (x)
#		define htole16(x) ((((((uint16_t)(x)) >> 8))|((((uint16_t)(x)) << 8)))
#		define betoh16(x) (x)
#		define letoh16(x) ((((((uint16_t)(x)) >> 8))|((((uint16_t)(x)) << 8)))

#		define htobe32(x) (x)
#		define htole32(x) (((uint32_t)htole16(((uint16_t)(((uint32_t)(x)) >> 16)))) | (((uint32_t)htole16(((uint16_t)(x)))) << 16))
#		define betoh32(x) (x)
#		define letoh32(x) (((uint32_t)le16toh(((uint16_t)(((uint32_t)(x)) >> 16)))) | (((uint32_t)le16toh(((uint16_t)(x)))) << 16))

#		define htobe64(x) (x)
#		define htole64(x) (((uint64_t)htole32(((uint32_t)(((uint64_t)(x)) >> 32)))) | (((uint64_t)htole32(((uint32_t)(x)))) << 32))
#		define betoh64(x) (x)
#		define letoh64(x) (((uint64_t)le32toh(((uint32_t)(((uint64_t)(x)) >> 32)))) | (((uint64_t)le32toh(((uint32_t)(x)))) << 32))
#	endif
#elif defined(ENDIANNESS_CONFIG_HAVE_OPENBSD_STYLE_ENDIAN_FUNCTIONS)
	/* Ah great, this defines all the functions we need */
#else
#	define htobe16(x) to_big_endian16(x)
#	define htole16(x) to_little_endian16(x)
#	define betoh16(x) from_big_endian16(x)
#	define letoh16(x) from_little_endian16(x)
#	define htobe32(x) to_big_endian32(x)
#	define htole32(x) to_little_endian32(x)
#	define betoh32(x) from_big_endian32(x)
#	define letoh32(x) from_little_endian32(x)
#	define htobe64(x) to_big_endian64(x)
#	define htole64(x) to_little_endian64(x)
#	define betoh64(x) from_big_endian64(x)
#	define letoh64(x) from_little_endian64(x)
#endif

union Endian_Data_16 {
	uint16_t integer_value;
	unsigned char char_values[2];
};
 
union Endian_Data_32 {
	uint32_t integer_value;
	unsigned char char_values[4];
};

union Endian_Data_64 {
	uint64_t integer_value;
	unsigned char char_values[8];
};

uint16_t to_little_endian16(uint16_t value) {
	union Endian_Data_16 endian_data;
	union Endian_Data_16 endian_data_copy;
	endian_data_copy.integer_value = value;
	
	endian_data.char_values[0] = endian_data_copy.char_values[ENDIANNESS_2_BYTE_TYPE_LSB_PLUS_0_INDEX];
	endian_data.char_values[1] = endian_data_copy.char_values[ENDIANNESS_2_BYTE_TYPE_LSB_PLUS_1_INDEX];
	
	return endian_data.integer_value;
}
uint32_t to_little_endian32(uint32_t value) {
	union Endian_Data_32 endian_data;
	union Endian_Data_32 endian_data_copy;
	endian_data_copy.integer_value = value;
	
	endian_data.char_values[0] = endian_data_copy.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_0_INDEX];
	endian_data.char_values[1] = endian_data_copy.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_1_INDEX];
	endian_data.char_values[2] = endian_data_copy.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_2_INDEX];
	endian_data.char_values[3] = endian_data_copy.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_3_INDEX];
	
	return endian_data.integer_value;
}
uint64_t to_little_endian64(uint64_t value) {
	union Endian_Data_64 endian_data;
	union Endian_Data_64 endian_data_copy;
	endian_data_copy.integer_value = value;
	
	endian_data.char_values[0] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_0_INDEX];
	endian_data.char_values[1] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_1_INDEX];
	endian_data.char_values[2] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_2_INDEX];
	endian_data.char_values[3] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_3_INDEX];
	endian_data.char_values[4] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_4_INDEX];
	endian_data.char_values[5] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_5_INDEX];
	endian_data.char_values[6] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_6_INDEX];
	endian_data.char_values[7] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_7_INDEX];
	
	return endian_data.integer_value;
}

uint16_t to_big_endian16(uint16_t value) {
	union Endian_Data_16 endian_data;
	union Endian_Data_16 endian_data_copy;
	endian_data_copy.integer_value = value;
	
	endian_data.char_values[0] = endian_data_copy.char_values[ENDIANNESS_2_BYTE_TYPE_LSB_PLUS_1_INDEX];
	endian_data.char_values[1] = endian_data_copy.char_values[ENDIANNESS_2_BYTE_TYPE_LSB_PLUS_0_INDEX];
	
	return endian_data.integer_value;
}
uint32_t to_big_endian32(uint32_t value) {
	union Endian_Data_32 endian_data;
	union Endian_Data_32 endian_data_copy;
	endian_data_copy.integer_value = value;
	
	endian_data.char_values[0] = endian_data_copy.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_3_INDEX];
	endian_data.char_values[1] = endian_data_copy.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_2_INDEX];
	endian_data.char_values[2] = endian_data_copy.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_1_INDEX];
	endian_data.char_values[3] = endian_data_copy.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_0_INDEX];
	
	return endian_data.integer_value;
}
uint64_t to_big_endian64(uint64_t value) {
	union Endian_Data_64 endian_data;
	union Endian_Data_64 endian_data_copy;
	endian_data_copy.integer_value = value;
	
	endian_data.char_values[0] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_7_INDEX];
	endian_data.char_values[1] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_6_INDEX];
	endian_data.char_values[2] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_5_INDEX];
	endian_data.char_values[3] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_4_INDEX];
	endian_data.char_values[4] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_3_INDEX];
	endian_data.char_values[5] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_2_INDEX];
	endian_data.char_values[6] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_1_INDEX];
	endian_data.char_values[7] = endian_data_copy.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_0_INDEX];
	
	return endian_data.integer_value;
}

uint16_t from_little_endian16(uint16_t value) {
	union Endian_Data_16 endian_data;
	union Endian_Data_16 endian_data_copy;
	endian_data_copy.integer_value = value;
	
	endian_data.char_values[ENDIANNESS_2_BYTE_TYPE_LSB_PLUS_0_INDEX] = endian_data_copy.char_values[0];
	endian_data.char_values[ENDIANNESS_2_BYTE_TYPE_LSB_PLUS_1_INDEX] = endian_data_copy.char_values[1];
	
	return endian_data.integer_value;
}
uint32_t from_little_endian32(uint32_t value) {
	union Endian_Data_32 endian_data;
	union Endian_Data_32 endian_data_copy;
	endian_data_copy.integer_value = value;
	
	endian_data.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_0_INDEX] = endian_data_copy.char_values[0];
	endian_data.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_1_INDEX] = endian_data_copy.char_values[1];
	endian_data.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_2_INDEX] = endian_data_copy.char_values[2];
	endian_data.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_3_INDEX] = endian_data_copy.char_values[3];
	
	return endian_data.integer_value;
}
uint64_t from_little_endian64(uint64_t value) {
	union Endian_Data_64 endian_data;
	union Endian_Data_64 endian_data_copy;
	endian_data_copy.integer_value = value;
	
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_0_INDEX] = endian_data_copy.char_values[0];
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_1_INDEX] = endian_data_copy.char_values[1];
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_2_INDEX] = endian_data_copy.char_values[2];
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_3_INDEX] = endian_data_copy.char_values[3];
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_4_INDEX] = endian_data_copy.char_values[4];
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_5_INDEX] = endian_data_copy.char_values[5];
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_6_INDEX] = endian_data_copy.char_values[6];
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_7_INDEX] = endian_data_copy.char_values[7];
	
	return endian_data.integer_value;
}

uint16_t from_big_endian16(uint16_t value) {
	union Endian_Data_16 endian_data;
	union Endian_Data_16 endian_data_copy;
	endian_data_copy.integer_value = value;
	
	endian_data.char_values[ENDIANNESS_2_BYTE_TYPE_LSB_PLUS_0_INDEX] = endian_data_copy.char_values[1];
	endian_data.char_values[ENDIANNESS_2_BYTE_TYPE_LSB_PLUS_1_INDEX] = endian_data_copy.char_values[0];
	
	return endian_data.integer_value;
}
uint32_t from_big_endian32(uint32_t value) {
	union Endian_Data_32 endian_data;
	union Endian_Data_32 endian_data_copy;
	endian_data_copy.integer_value = value;
	
	endian_data.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_0_INDEX] = endian_data_copy.char_values[3];
	endian_data.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_1_INDEX] = endian_data_copy.char_values[2];
	endian_data.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_2_INDEX] = endian_data_copy.char_values[1];
	endian_data.char_values[ENDIANNESS_4_BYTE_TYPE_LSB_PLUS_3_INDEX] = endian_data_copy.char_values[0];
	
	return endian_data.integer_value;
}
uint64_t from_big_endian64(uint64_t value) {
	union Endian_Data_64 endian_data;
	union Endian_Data_64 endian_data_copy;
	endian_data_copy.integer_value = value;
	
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_0_INDEX] = endian_data_copy.char_values[7];
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_1_INDEX] = endian_data_copy.char_values[6];
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_2_INDEX] = endian_data_copy.char_values[5];
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_3_INDEX] = endian_data_copy.char_values[4];
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_4_INDEX] = endian_data_copy.char_values[3];
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_5_INDEX] = endian_data_copy.char_values[2];
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_6_INDEX] = endian_data_copy.char_values[1];
	endian_data.char_values[ENDIANNESS_8_BYTE_TYPE_LSB_PLUS_7_INDEX] = endian_data_copy.char_values[0];
	
	return endian_data.integer_value;
}

#endif // ENDIANNESS_GENERATED_CONFIG_H_
